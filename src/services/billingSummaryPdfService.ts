import { jsPDF } from 'jspdf';
import 'jspdf-autotable';
import { Invoice, Client, Product } from '../types';

export interface BillingSummarySettings {
  // Layout Settings
  paperSize: 'letter' | 'a4' | 'legal';
  orientation: 'portrait' | 'landscape';
  margins: number; // in mm
  
  // Content Settings
  title: string;
  subtitle: string;
  includeClientBreakdown: boolean;
  includeProductBreakdown: boolean;
  includeChargeDetails: boolean;
  includeDateRange: boolean;
  includeInvoiceList: boolean;
  
  // Grouping Settings
  groupBy: 'none' | 'client' | 'deliveryDate' | 'invoiceNumber';
  sortBy: 'invoiceNumber' | 'deliveryDate' | 'clientName' | 'total';
  sortOrder: 'asc' | 'desc';
  
  // Display Settings
  showSubtotals: boolean;
  showCharges: boolean;
  showTotals: boolean;
  showQuantities: boolean;
  showPrices: boolean;
  
  // Summary Settings
  includeSummaryTable: boolean;
  includeGrandTotal: boolean;
  includeStatistics: boolean;
  
  // Styling
  headerColor: string;
  textColor: string;
  fontSize: number;
  logoUrl?: string;
  
  // Footer
  footerText: string;
  includeTimestamp: boolean;
}

export const DEFAULT_BILLING_SUMMARY_SETTINGS: BillingSummarySettings = {
  paperSize: 'letter',
  orientation: 'portrait',
  margins: 15,
  title: 'Billing Summary Report',
  subtitle: 'Invoice Summary for Selected Period',
  includeClientBreakdown: true,
  includeProductBreakdown: true,
  includeChargeDetails: true,
  includeDateRange: true,
  includeInvoiceList: true,
  groupBy: 'client',
  sortBy: 'deliveryDate',
  sortOrder: 'asc',
  showSubtotals: true,
  showCharges: true,
  showTotals: true,
  showQuantities: true,
  showPrices: true,
  includeSummaryTable: true,
  includeGrandTotal: true,
  includeStatistics: true,
  headerColor: '#0E62A0',
  textColor: '#000000',
  fontSize: 10,
  footerText: 'Generated by King Uniforms Billing System',
  includeTimestamp: true,
};

export interface ProcessedInvoiceData {
  invoice: Invoice;
  client: Client;
  subtotal: number;
  charges: {
    serviceCharge: number;
    fuelCharge: number;
    surcharge: number;
    deliveryCharge: number;
    generalDeliveryCharge: number;
    disposableFee: number;
  };
  total: number;
  productSummary: Array<{
    productName: string;
    quantity: number;
    price: number;
    amount: number;
  }>;
}

export async function generateBillingSummaryPDF(
  selectedInvoices: Invoice[],
  clients: Client[],
  products: Product[],
  settings: BillingSummarySettings,
  chargeSettings?: {
    serviceChargeEnabled: boolean;
    serviceChargePercent: string;
    serviceChargeFormula: string;
    fuelChargeEnabled: boolean;
    fuelChargePercent: string;
    fuelChargeFormula: string;
    surchargeEnabled: boolean;
    surchargePercent: string;
    surchargeFormula: string;
    deliveryCharge: string;
    deliveryChargeFormula: string;
    generalDeliveryCharge: string;
    generalDeliveryChargeFormula: string;
    disposableFee: string;
    disposableFeeFormula: string;
    minBilling: string;
    productPrices: Record<string, number>;
  }
): Promise<string> {
  console.log('ðŸ“„ Starting Billing Summary PDF generation...');
  
  // Process invoice data
  const processedData = processInvoiceData(
    selectedInvoices, 
    clients, 
    products, 
    chargeSettings
  );
  
  // Create PDF with settings
  const pdf = new jsPDF({
    orientation: settings.orientation,
    unit: 'mm',
    format: settings.paperSize
  });

  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = settings.margins;
  const contentWidth = pageWidth - (margin * 2);

  let yPos = margin;

  // Add header
  yPos = addHeader(pdf, settings, pageWidth, margin, yPos);
  
  // Add date range if enabled
  if (settings.includeDateRange) {
    yPos = addDateRange(pdf, selectedInvoices, settings, margin, yPos);
  }

  // Add statistics if enabled
  if (settings.includeStatistics) {
    yPos = addStatistics(pdf, processedData, settings, margin, contentWidth, yPos);
  }

  // Add summary table if enabled
  if (settings.includeSummaryTable) {
    yPos = addSummaryTable(pdf, processedData, settings, margin, contentWidth, yPos);
  }

  // Add detailed breakdown based on grouping
  yPos = addDetailedBreakdown(pdf, processedData, settings, margin, contentWidth, yPos, pageHeight);

  // Add footer
  addFooter(pdf, settings, pageWidth, pageHeight, margin);

  const pdfAsString = pdf.output('datauristring');
  console.log('âœ… Billing Summary PDF generated successfully');
  
  return pdfAsString;
}

function processInvoiceData(
  selectedInvoices: Invoice[],
  clients: Client[],
  products: Product[],
  chargeSettings?: any
): ProcessedInvoiceData[] {
  return selectedInvoices.map(invoice => {
    const client = clients.find(c => c.id === invoice.clientId)!;
    
    // Calculate subtotal
    let subtotal = 0;
    const productSummary: Array<{
      productName: string;
      quantity: number;
      price: number;
      amount: number;
    }> = [];

    // Process products from carts
    if (invoice.carts && chargeSettings?.productPrices) {
      const clientProducts = products.filter(p => 
        client.selectedProducts?.includes(p.id)
      );

      clientProducts.forEach(prod => {
        if (!prod.name.toLowerCase().includes("peso")) {
          const qty = (invoice.carts || []).reduce((sum, cart) => {
            return sum + (cart.items || [])
              .filter(item => item.productId === prod.id)
              .reduce((s, item) => s + (Number(item.quantity) || 0), 0);
          }, 0);
          
          const price = chargeSettings.productPrices[prod.id] || 0;
          const amount = qty > 0 && price > 0 ? qty * price : 0;
          
          if (qty > 0) {
            productSummary.push({
              productName: prod.name,
              quantity: qty,
              price,
              amount
            });
            subtotal += amount;
          }
        }
      });

      // Handle peso calculations
      const pesoProduct = clientProducts.find(prod =>
        prod.name.toLowerCase().includes("peso")
      );
      
      if (pesoProduct && typeof invoice.totalWeight === "number") {
        const pesoPrice = chargeSettings.productPrices[pesoProduct.id];
        if (pesoPrice && pesoPrice > 0) {
          const pesoAmount = invoice.totalWeight * pesoPrice;
          productSummary.push({
            productName: `${pesoProduct.name} (${invoice.totalWeight} lbs)`,
            quantity: invoice.totalWeight,
            price: pesoPrice,
            amount: pesoAmount
          });
          subtotal += pesoAmount;
        }
      }
    }

    // Calculate charges (simplified version)
    const charges = {
      serviceCharge: 0,
      fuelCharge: 0,
      surcharge: 0,
      deliveryCharge: 0,
      generalDeliveryCharge: 0,
      disposableFee: 0
    };

    // Apply minimum billing if configured
    const minValue = chargeSettings?.minBilling ? Number(chargeSettings.minBilling) : 0;
    let effectiveSubtotal = subtotal;
    if (minValue > 0 && subtotal < minValue) {
      effectiveSubtotal = minValue;
    }

    // Calculate basic charges (you can expand this based on your existing logic)
    if (chargeSettings?.serviceChargeEnabled && chargeSettings?.serviceChargePercent) {
      charges.serviceCharge = effectiveSubtotal * (Number(chargeSettings.serviceChargePercent) / 100);
    }
    
    if (chargeSettings?.fuelChargeEnabled && chargeSettings?.fuelChargePercent) {
      charges.fuelCharge = effectiveSubtotal * (Number(chargeSettings.fuelChargePercent) / 100);
    }

    if (chargeSettings?.surchargeEnabled && chargeSettings?.surchargePercent) {
      charges.surcharge = effectiveSubtotal * (Number(chargeSettings.surchargePercent) / 100);
    }

    const totalCharges = Object.values(charges).reduce((sum, charge) => sum + charge, 0);
    const total = effectiveSubtotal + totalCharges;

    return {
      invoice,
      client,
      subtotal: effectiveSubtotal,
      charges,
      total,
      productSummary
    };
  });
}

function addHeader(
  pdf: jsPDF, 
  settings: BillingSummarySettings, 
  pageWidth: number, 
  margin: number, 
  yPos: number
): number {
  // Company header
  pdf.setFontSize(20);
  pdf.setFont('helvetica', 'bold');
  pdf.setTextColor(settings.headerColor);
  pdf.text('King Uniforms', pageWidth / 2, yPos, { align: 'center' });
  yPos += 10;

  // Title
  pdf.setFontSize(16);
  pdf.text(settings.title, pageWidth / 2, yPos, { align: 'center' });
  yPos += 8;

  // Subtitle
  if (settings.subtitle) {
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'normal');
    pdf.text(settings.subtitle, pageWidth / 2, yPos, { align: 'center' });
    yPos += 8;
  }

  // Reset text color
  pdf.setTextColor(settings.textColor);
  yPos += 5;

  return yPos;
}

function addDateRange(
  pdf: jsPDF,
  selectedInvoices: Invoice[],
  settings: BillingSummarySettings,
  margin: number,
  yPos: number
): number {
  const dates = selectedInvoices
    .map(inv => inv.deliveryDate || inv.date)
    .filter(Boolean)
    .map(date => new Date(date!))
    .sort((a, b) => a.getTime() - b.getTime());

  if (dates.length > 0) {
    const startDate = dates[0].toLocaleDateString();
    const endDate = dates[dates.length - 1].toLocaleDateString();
    const dateRange = startDate === endDate ? startDate : `${startDate} to ${endDate}`;
    
    pdf.setFontSize(settings.fontSize + 1);
    pdf.setFont('helvetica', 'bold');
    pdf.text(`Period: ${dateRange}`, margin, yPos);
    yPos += 8;
  }

  return yPos;
}

function addStatistics(
  pdf: jsPDF,
  processedData: ProcessedInvoiceData[],
  settings: BillingSummarySettings,
  margin: number,
  contentWidth: number,
  yPos: number
): number {
  pdf.setFontSize(settings.fontSize + 2);
  pdf.setFont('helvetica', 'bold');
  pdf.text('Summary Statistics', margin, yPos);
  yPos += 8;

  const stats = calculateStatistics(processedData);
  
  pdf.setFontSize(settings.fontSize);
  pdf.setFont('helvetica', 'normal');
  
  const statsText = [
    `Total Invoices: ${stats.totalInvoices}`,
    `Unique Clients: ${stats.uniqueClients}`,
    `Total Items: ${stats.totalItems}`,
    `Total Quantity: ${stats.totalQuantity.toLocaleString()}`,
    `Subtotal: $${stats.subtotal.toFixed(2)}`,
    `Total Charges: $${stats.totalCharges.toFixed(2)}`,
    `Grand Total: $${stats.grandTotal.toFixed(2)}`
  ];

  const colWidth = contentWidth / 2;
  statsText.forEach((text, index) => {
    const x = margin + (index % 2) * colWidth;
    const y = yPos + Math.floor(index / 2) * 6;
    pdf.text(text, x, y);
  });

  yPos += Math.ceil(statsText.length / 2) * 6 + 10;
  return yPos;
}

function addSummaryTable(
  pdf: jsPDF,
  processedData: ProcessedInvoiceData[],
  settings: BillingSummarySettings,
  margin: number,
  contentWidth: number,
  yPos: number
): number {
  pdf.setFontSize(settings.fontSize + 2);
  pdf.setFont('helvetica', 'bold');
  pdf.text('Client Summary', margin, yPos);
  yPos += 8;

  // Group by client
  const clientSummary = groupByClient(processedData);
  
  const tableData = clientSummary.map(group => [
    group.clientName,
    group.invoiceCount.toString(),
    `$${group.subtotal.toFixed(2)}`,
    `$${group.charges.toFixed(2)}`,
    `$${group.total.toFixed(2)}`
  ]);

  (pdf as any).autoTable({
    startY: yPos,
    head: [['Client', 'Invoices', 'Subtotal', 'Charges', 'Total']],
    body: tableData,
    margin: { left: margin, right: margin },
    styles: {
      fontSize: settings.fontSize - 1,
      cellPadding: 3,
    },
    headStyles: {
      fillColor: settings.headerColor,
      textColor: 255,
      fontStyle: 'bold'
    },
    columnStyles: {
      1: { halign: 'center' },
      2: { halign: 'right' },
      3: { halign: 'right' },
      4: { halign: 'right' }
    }
  });

  return (pdf as any).lastAutoTable.finalY + 10;
}

function addDetailedBreakdown(
  pdf: jsPDF,
  processedData: ProcessedInvoiceData[],
  settings: BillingSummarySettings,
  margin: number,
  contentWidth: number,
  yPos: number,
  pageHeight: number
): number {
  if (!settings.includeInvoiceList) return yPos;

  pdf.setFontSize(settings.fontSize + 2);
  pdf.setFont('helvetica', 'bold');
  pdf.text('Detailed Invoice List', margin, yPos);
  yPos += 8;

  // Sort data based on settings
  const sortedData = sortProcessedData(processedData, settings);
  
  const tableData = sortedData.map(item => {
    const row = [
      item.invoice.invoiceNumber || item.invoice.id,
      item.client.name,
      item.invoice.deliveryDate ? 
        new Date(item.invoice.deliveryDate).toLocaleDateString() : 
        (item.invoice.date ? new Date(item.invoice.date).toLocaleDateString() : '-')
    ];

    if (settings.showSubtotals) row.push(`$${item.subtotal.toFixed(2)}`);
    if (settings.showCharges) {
      const totalCharges = Object.values(item.charges).reduce((sum, charge) => sum + charge, 0);
      row.push(`$${totalCharges.toFixed(2)}`);
    }
    if (settings.showTotals) row.push(`$${item.total.toFixed(2)}`);

    return row;
  });

  const headers = ['Invoice #', 'Client', 'Date'];
  if (settings.showSubtotals) headers.push('Subtotal');
  if (settings.showCharges) headers.push('Charges');
  if (settings.showTotals) headers.push('Total');

  (pdf as any).autoTable({
    startY: yPos,
    head: [headers],
    body: tableData,
    margin: { left: margin, right: margin },
    styles: {
      fontSize: settings.fontSize - 1,
      cellPadding: 2,
    },
    headStyles: {
      fillColor: settings.headerColor,
      textColor: 255,
      fontStyle: 'bold'
    },
    columnStyles: {
      3: { halign: 'right' },
      4: { halign: 'right' },
      5: { halign: 'right' }
    }
  });

  return (pdf as any).lastAutoTable.finalY + 5;
}

function addFooter(
  pdf: jsPDF,
  settings: BillingSummarySettings,
  pageWidth: number,
  pageHeight: number,
  margin: number
): void {
  const footerY = pageHeight - margin;
  
  pdf.setFontSize(8);
  pdf.setFont('helvetica', 'italic');
  pdf.setTextColor(100, 100, 100);
  
  // Footer text
  if (settings.footerText) {
    pdf.text(settings.footerText, margin, footerY);
  }
  
  // Timestamp
  if (settings.includeTimestamp) {
    const timestamp = new Date().toLocaleString();
    pdf.text(`Generated: ${timestamp}`, pageWidth - margin, footerY, { align: 'right' });
  }
}

function calculateStatistics(processedData: ProcessedInvoiceData[]) {
  const uniqueClients = new Set(processedData.map(item => item.client.id)).size;
  const totalItems = processedData.reduce((sum, item) => sum + item.productSummary.length, 0);
  const totalQuantity = processedData.reduce((sum, item) => 
    sum + item.productSummary.reduce((qtySum, product) => qtySum + product.quantity, 0), 0
  );
  const subtotal = processedData.reduce((sum, item) => sum + item.subtotal, 0);
  const totalCharges = processedData.reduce((sum, item) => 
    sum + Object.values(item.charges).reduce((chargeSum, charge) => chargeSum + charge, 0), 0
  );
  const grandTotal = processedData.reduce((sum, item) => sum + item.total, 0);

  return {
    totalInvoices: processedData.length,
    uniqueClients,
    totalItems,
    totalQuantity,
    subtotal,
    totalCharges,
    grandTotal
  };
}

function groupByClient(processedData: ProcessedInvoiceData[]) {
  const groups = new Map<string, {
    clientName: string;
    invoiceCount: number;
    subtotal: number;
    charges: number;
    total: number;
  }>();

  processedData.forEach(item => {
    const existing = groups.get(item.client.id) || {
      clientName: item.client.name,
      invoiceCount: 0,
      subtotal: 0,
      charges: 0,
      total: 0
    };

    const itemCharges = Object.values(item.charges).reduce((sum, charge) => sum + charge, 0);
    
    existing.invoiceCount++;
    existing.subtotal += item.subtotal;
    existing.charges += itemCharges;
    existing.total += item.total;

    groups.set(item.client.id, existing);
  });

  return Array.from(groups.values());
}

function sortProcessedData(
  processedData: ProcessedInvoiceData[],
  settings: BillingSummarySettings
): ProcessedInvoiceData[] {
  return [...processedData].sort((a, b) => {
    let result = 0;
    
    switch (settings.sortBy) {
      case 'invoiceNumber':
        const aNum = Number(a.invoice.invoiceNumber) || 0;
        const bNum = Number(b.invoice.invoiceNumber) || 0;
        result = aNum - bNum;
        break;
      case 'deliveryDate':
        const aDate = new Date(a.invoice.deliveryDate || a.invoice.date || 0);
        const bDate = new Date(b.invoice.deliveryDate || b.invoice.date || 0);
        result = aDate.getTime() - bDate.getTime();
        break;
      case 'clientName':
        result = a.client.name.localeCompare(b.client.name);
        break;
      case 'total':
        result = a.total - b.total;
        break;
    }
    
    return settings.sortOrder === 'desc' ? -result : result;
  });
}
